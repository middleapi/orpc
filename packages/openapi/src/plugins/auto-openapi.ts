import type { AnySchema, OpenAPI } from '@orpc/contract'
import type { Context, HTTPPath, Router } from '@orpc/server'
import type { StandardHandlerInterceptorOptions, StandardHandlerOptions, StandardHandlerPlugin } from '@orpc/server/standard'
import type { Promisable, Value } from '@orpc/shared'
import type {
  OpenAPIGeneratorGenerateOptions,
  OpenAPIGeneratorOptions,
} from '../openapi-generator'
import { type } from '@orpc/contract'
import { once, stringifyJSON, value } from '@orpc/shared'
import { OpenAPIGenerator } from '../openapi-generator'

/**
 * Supported documentation UI providers.
 */
type DocsProvider = 'scalar' | 'swagger'

/**
 * CDN URLs for documentation UI libraries.
 */
const DOCS_CDN_URLS = {
  scalar: {
    script: 'https://cdn.jsdelivr.net/npm/@scalar/api-reference',
    css: undefined,
  },
  swagger: {
    script: 'https://unpkg.com/swagger-ui-dist@5.17.14/swagger-ui-bundle.js',
    css: 'https://unpkg.com/swagger-ui-dist@5.17.14/swagger-ui.css',
  },
} as const

/**
 * Default values for plugin configuration.
 */
const DEFAULT_CONFIG = {
  specPath: '/spec.json' as HTTPPath,
  docsPath: '/' as HTTPPath,
  docsTitle: 'API Reference',
  docsHead: '',
  docsProvider: 'scalar' as DocsProvider,
  autoGenerateSummary: true,
  autoGenerateTags: true,
  autoGenerateDescription: false,
} as const

/**
 * Configuration options for the AutoOpenAPIPlugin.
 *
 * @template T - The context type extending Context
 */
export interface AutoOpenAPIPluginOptions<
  T extends Context = Context,
> extends OpenAPIGeneratorOptions {
  /**
   * Options to pass to the OpenAPI generator.
   */
  specGenerateOptions?: Value<
    Promisable<OpenAPIGeneratorGenerateOptions>,
    [StandardHandlerInterceptorOptions<T>]
  >

  /**
   * The URL path at which to serve the OpenAPI JSON.
   *
   * @default '/spec.json'
   */
  specPath?: HTTPPath

  /**
   * The URL path at which to serve the API reference UI.
   *
   * @default '/'
   */
  docsPath?: HTTPPath

  /**
   * The document title for the API reference UI.
   *
   * @default 'API Reference'
   */
  docsTitle?: Value<Promisable<string>, [StandardHandlerInterceptorOptions<T>]>

  /**
   * The UI library to use for rendering the API reference.
   *
   * @default 'scalar'
   */
  docsProvider?: DocsProvider

  /**
   * Arbitrary configuration object for the UI.
   */
  docsConfig?: Value<Promisable<Record<string, unknown>>, [StandardHandlerInterceptorOptions<T>]>

  /**
   * HTML to inject into the <head> of the docs page.
   *
   * @default ''
   */
  docsHead?: Value<Promisable<string>, [StandardHandlerInterceptorOptions<T>]>

  /**
   * URL of the external script bundle for the reference UI.
   *
   * @default CDN URL based on docsProvider
   */
  docsScriptUrl?: Value<Promisable<string>, [StandardHandlerInterceptorOptions<T>]>

  /**
   * URL of the external CSS bundle for the reference UI (used by Swagger UI).
   *
   * @default CDN URL based on docsProvider
   */
  docsCssUrl?: Value<Promisable<string | undefined>, [StandardHandlerInterceptorOptions<T>]>

  /**
   * Default schema to use when output schema is not defined.
   * Set to undefined to skip adding default output schemas.
   *
   * @default type() - A generic type schema
   */
  defaultOutputSchema?: AnySchema

  /**
   * Whether to auto-generate summary from procedure names.
   * When enabled, generates human-readable summaries like "List Products" from path "products.list".
   *
   * @default true
   */
  autoGenerateSummary?: boolean

  /**
   * Whether to auto-generate tags from router structure.
   * When enabled, uses the first path segment as a tag for grouping endpoints.
   *
   * @default true
   */
  autoGenerateTags?: boolean

  /**
   * Whether to auto-generate descriptions from procedure names.
   * When enabled, generates descriptions based on the auto-generated summary.
   *
   * @default false
   */
  autoGenerateDescription?: boolean

  /**
   * Override function to generate the full HTML for the docs page.
   * Allows complete customization of the documentation UI rendering.
   *
   * @param specUrl - URL where the OpenAPI spec is served
   * @param title - Document title
   * @param head - Additional HTML for the head section
   * @param scriptUrl - URL of the UI library script
   * @param config - Configuration object for the UI
   * @param spec - The generated OpenAPI specification
   * @param docsProvider - The UI provider being used
   * @param cssUrl - URL of the CSS file (for Swagger UI)
   * @returns Complete HTML document as a string
   */
  renderDocsHtml?: (
    specUrl: string,
    title: string,
    head: string,
    scriptUrl: string,
    config: Record<string, unknown> | undefined,
    spec: OpenAPI.Document,
    docsProvider: DocsProvider,
    cssUrl: string | undefined,
  ) => string
}

/**
 * Common CRUD operation mappings for generating human-readable summaries.
 */
const CRUD_OPERATIONS: Record<string, string> = {
  list: 'List',
  find: 'Find',
  get: 'Get',
  create: 'Create',
  update: 'Update',
  delete: 'Delete',
  remove: 'Remove',
} as const

/**
 * Utility class for generating OpenAPI metadata from procedure paths.
 */
class MetadataGenerator {
  /**
   * Capitalizes the first letter of a string.
   */
  private static capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  /**
   * Converts a path segment array into a human-readable resource name.
   */
  private static formatResourceName(segments: readonly string[]): string {
    return segments
      .map(segment => this.capitalize(segment))
      .join(' ')
  }

  /**
   * Determines if a resource name should be pluralized.
   */
  private static shouldPluralize(operation: string, resource: string): boolean {
    return operation.toLowerCase() === 'list' && !resource.endsWith('s')
  }

  /**
   * Converts a dot-separated path to a human-readable summary.
   *
   * @example
   * generateSummary(['planet', 'list']) // => 'List Planets'
   * generateSummary(['planet', 'find']) // => 'Find Planet'
   * generateSummary(['user', 'profile', 'update']) // => 'Update User Profile'
   *
   * @param path - Array of path segments representing the procedure location
   * @returns Human-readable summary string
   */
  static generateSummary(path: readonly string[]): string {
    if (path.length === 0) {
      return 'Procedure'
    }

    const lastSegment = path[path.length - 1]!
    const action = this.capitalize(lastSegment)

    if (path.length === 1) {
      return action
    }

    const resource = this.formatResourceName(path.slice(0, -1))
    const operation = CRUD_OPERATIONS[lastSegment.toLowerCase()] ?? action

    if (this.shouldPluralize(lastSegment, resource)) {
      return `${operation} ${resource}s`
    }

    return `${operation} ${resource}`
  }

  /**
   * Generates a description from the procedure path.
   *
   * @param path - Array of path segments
   * @returns Generated description string
   */
  static generateDescription(path: readonly string[]): string {
    if (path.length === 0) {
      return 'Executes a procedure'
    }

    const summary = this.generateSummary(path)
    return `${summary} operation`
  }

  /**
   * Extracts tags from the router path structure.
   * Uses the first path segment as the primary tag for grouping.
   *
   * @example
   * generateTags(['planet', 'list']) // => ['planet']
   * generateTags(['user', 'profile', 'update']) // => ['user']
   *
   * @param path - Array of path segments
   * @returns Array of tag strings
   */
  static generateTags(path: readonly string[]): string[] {
    if (path.length <= 1) {
      return []
    }

    return [path[0]!]
  }
}

/**
 * Configuration for wrapping routers with default metadata.
 */
interface RouterWrapperConfig {
  defaultOutputSchema?: AnySchema
  autoGenerateSummary?: boolean
  autoGenerateTags?: boolean
  autoGenerateDescription?: boolean
}

/**
 * Internal configuration type with required fields (except defaultOutputSchema).
 */
type InternalRouterWrapperConfig = Omit<Required<RouterWrapperConfig>, 'defaultOutputSchema'> & {
  defaultOutputSchema: AnySchema | undefined
}

/**
 * Utility class for wrapping routers with default schemas and metadata.
 */
class RouterWrapper {
  private readonly config: InternalRouterWrapperConfig

  constructor(config: RouterWrapperConfig) {
    this.config = {
      defaultOutputSchema: config.defaultOutputSchema,
      autoGenerateSummary: config.autoGenerateSummary ?? true,
      autoGenerateTags: config.autoGenerateTags ?? true,
      autoGenerateDescription: config.autoGenerateDescription ?? false,
    }
  }

  /**
   * Checks if a procedure needs metadata updates.
   */
  private needsMetadataUpdate(def: any): boolean {
    return (
      (this.config.autoGenerateSummary && !def.route.summary)
      || (this.config.autoGenerateDescription && !def.route.description)
      || (this.config.autoGenerateTags && (!def.route.tags || def.route.tags.length === 0))
    )
  }

  /**
   * Checks if a procedure needs a default output schema.
   */
  private needsOutputSchema(def: any): boolean {
    return !def.outputSchema && Boolean(this.config.defaultOutputSchema)
  }

  /**
   * Generates route metadata for a procedure.
   */
  private generateRouteMetadata(path: readonly string[], currentRoute: any): any {
    const newRoute = { ...currentRoute }

    if (this.config.autoGenerateSummary && !newRoute.summary) {
      newRoute.summary = MetadataGenerator.generateSummary(path)
    }

    if (this.config.autoGenerateDescription && !newRoute.description) {
      newRoute.description = MetadataGenerator.generateDescription(path)
    }

    if (this.config.autoGenerateTags && (!newRoute.tags || newRoute.tags.length === 0)) {
      const tags = MetadataGenerator.generateTags(path)
      if (tags.length > 0) {
        newRoute.tags = tags
      }
    }

    return newRoute
  }

  /**
   * Wraps a single procedure with default schemas and metadata.
   */
  private wrapProcedure(procedure: any, path: readonly string[]): any {
    const def = procedure['~orpc']

    const needsUpdate = this.needsMetadataUpdate(def)
    const needsSchema = this.needsOutputSchema(def)

    // If nothing needs to be changed, return the original procedure
    if (!needsUpdate && !needsSchema) {
      return procedure
    }

    // Create a new procedure definition with updated metadata
    // Preserve all other properties including inputSchema to avoid breaking schema references
    const newDef = {
      ...def,
      route: needsUpdate ? this.generateRouteMetadata(path, def.route) : def.route,
      ...(needsSchema ? { outputSchema: this.config.defaultOutputSchema } : {}),
    }

    return {
      ...procedure,
      '~orpc': newDef,
    } as any
  }

  /**
   * Recursively processes a router structure, wrapping procedures with defaults.
   */
  private processRouter(item: unknown, currentPath: readonly string[] = []): unknown {
    // Check if it's a procedure
    if (item && typeof item === 'object' && '~orpc' in item) {
      return this.wrapProcedure(item as any, currentPath)
    }

    // Check if it's a router (object with nested items)
    if (item && typeof item === 'object' && !Array.isArray(item)) {
      const result: Record<string, unknown> = {}

      for (const [key, value] of Object.entries(item)) {
        result[key] = this.processRouter(value, [...currentPath, key])
      }

      return result
    }

    return item
  }

  /**
   * Wraps a router with default output schemas and auto-generated metadata.
   */
  wrap(router: any): any {
    return this.processRouter(router)
  }
}

/**
 * Plugin that automatically generates OpenAPI documentation with sensible defaults.
 *
 * Features:
 * - Auto-generates summaries, tags, and descriptions from procedure names
 * - Provides default output schemas when not explicitly defined
 * - Serves interactive API documentation (Scalar or Swagger UI)
 * - Serves OpenAPI specification as JSON
 *
 * @template T - The context type extending Context
 *
 * @example
 * ```typescript
 * import { AutoOpenAPIPlugin } from '@orpc/openapi/plugins'
 * import { ZodToJsonSchemaConverter } from '@orpc/zod/zod4'
 *
 * const plugin = new AutoOpenAPIPlugin({
 *   schemaConverters: [new ZodToJsonSchemaConverter()],
 *   docsProvider: 'swagger',
 *   specGenerateOptions: {
 *     info: {
 *       title: 'My API',
 *       version: '1.0.0',
 *     },
 *   },
 * })
 * ```
 */
export class AutoOpenAPIPlugin<
  T extends Context = Context,
> implements StandardHandlerPlugin<T> {
  private readonly generator: OpenAPIGenerator
  private readonly config: {
    specGenerateOptions: AutoOpenAPIPluginOptions<T>['specGenerateOptions']
    specPath: HTTPPath
    docsPath: HTTPPath
    docsTitle: Value<Promisable<string>, [StandardHandlerInterceptorOptions<T>]>
    docsHead: Value<Promisable<string>, [StandardHandlerInterceptorOptions<T>]>
    docsProvider: DocsProvider
    docsScriptUrl: Value<Promisable<string>, [StandardHandlerInterceptorOptions<T>]>
    docsCssUrl: Value<Promisable<string | undefined>, [StandardHandlerInterceptorOptions<T>]>
    docsConfig: AutoOpenAPIPluginOptions<T>['docsConfig']
    renderDocsHtml: Exclude<AutoOpenAPIPluginOptions<T>['renderDocsHtml'], undefined>
    defaultOutputSchema: AnySchema | undefined
    autoGenerateSummary: boolean
    autoGenerateTags: boolean
    autoGenerateDescription: boolean
  }

  constructor(options: AutoOpenAPIPluginOptions<T> = {}) {
    const docsProvider = options.docsProvider ?? DEFAULT_CONFIG.docsProvider
    const cdnUrls = DOCS_CDN_URLS[docsProvider]

    this.config = {
      specGenerateOptions: options.specGenerateOptions,
      specPath: options.specPath ?? DEFAULT_CONFIG.specPath,
      docsPath: options.docsPath ?? DEFAULT_CONFIG.docsPath,
      docsTitle: options.docsTitle ?? DEFAULT_CONFIG.docsTitle,
      docsHead: options.docsHead ?? DEFAULT_CONFIG.docsHead,
      docsProvider,
      docsScriptUrl: options.docsScriptUrl ?? cdnUrls.script,
      docsCssUrl: options.docsCssUrl ?? cdnUrls.css,
      docsConfig: options.docsConfig,
      renderDocsHtml: options.renderDocsHtml ?? this.#defaultRenderDocsHtml.bind(this),
      defaultOutputSchema: options.defaultOutputSchema ?? type(),
      autoGenerateSummary: options.autoGenerateSummary ?? DEFAULT_CONFIG.autoGenerateSummary,
      autoGenerateTags: options.autoGenerateTags ?? DEFAULT_CONFIG.autoGenerateTags,
      autoGenerateDescription: options.autoGenerateDescription ?? DEFAULT_CONFIG.autoGenerateDescription,
    }

    this.generator = new OpenAPIGenerator(options)
  }

  /**
   * Initializes the plugin by adding interceptors to handle OpenAPI spec and docs requests.
   */
  init(options: StandardHandlerOptions<T>, router: Router<any, T>): void {
    options.interceptors ??= []

    options.interceptors.push(async (interceptorOptions) => {
      const res = await interceptorOptions.next()

      // Only handle unmatched GET requests
      if (res.matched || interceptorOptions.request.method !== 'GET') {
        return res
      }

      const prefix = interceptorOptions.prefix ?? ''
      const requestPathname = interceptorOptions.request.url.pathname.replace(/\/$/, '') || '/'
      const docsUrl = new URL(
        `${prefix}${this.config.docsPath}`.replace(/\/$/, ''),
        interceptorOptions.request.url.origin,
      )
      const specUrl = new URL(
        `${prefix}${this.config.specPath}`.replace(/\/$/, ''),
        interceptorOptions.request.url.origin,
      )

      // Lazy generate spec only once
      const generateSpec = once(async () => {
        const wrapper = new RouterWrapper({
          defaultOutputSchema: this.config.defaultOutputSchema,
          autoGenerateSummary: this.config.autoGenerateSummary,
          autoGenerateTags: this.config.autoGenerateTags,
          autoGenerateDescription: this.config.autoGenerateDescription,
        })

        const wrappedRouter = wrapper.wrap(router)

        return await this.generator.generate(wrappedRouter, {
          servers: [
            { url: new URL(prefix, interceptorOptions.request.url.origin).toString() },
          ],
          ...(await value(this.config.specGenerateOptions, interceptorOptions)),
        })
      })

      // Handle OpenAPI spec JSON request
      if (requestPathname === specUrl.pathname) {
        const spec = await generateSpec()

        return {
          matched: true,
          response: {
            status: 200,
            headers: {},
            body: new File([stringifyJSON(spec)], 'spec.json', {
              type: 'application/json',
            }),
          },
        }
      }

      // Handle API docs UI request
      if (requestPathname === docsUrl.pathname) {
        const html = this.config.renderDocsHtml(
          specUrl.toString(),
          await value(this.config.docsTitle, interceptorOptions),
          await value(this.config.docsHead, interceptorOptions),
          await value(this.config.docsScriptUrl, interceptorOptions),
          await value(this.config.docsConfig, interceptorOptions),
          await generateSpec(),
          this.config.docsProvider,
          await value(this.config.docsCssUrl, interceptorOptions),
        )

        return {
          matched: true,
          response: {
            status: 200,
            headers: {},
            body: new File([html], 'api-reference.html', { type: 'text/html' }),
          },
        }
      }

      return res
    })
  }

  /**
   * Escapes HTML special characters to prevent XSS attacks.
   *
   * @private
   */
  #esc(s: string): string {
    return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
  }

  /**
   * Renders the default HTML for the API documentation page.
   * Can be overridden by providing a custom renderDocsHtml function in options.
   *
   * @private
   */
  #defaultRenderDocsHtml(
    specUrl: string,
    title: string,
    head: string,
    scriptUrl: string,
    config: Record<string, unknown> | undefined,
    _spec: OpenAPI.Document,
    docsProvider: DocsProvider,
    cssUrl: string | undefined,
  ): string {
    if (docsProvider === 'swagger') {
      return this.#renderSwaggerUI(specUrl, title, head, scriptUrl, config, cssUrl)
    }

    return this.#renderScalarUI(specUrl, title, head, scriptUrl, config)
  }

  /**
   * Renders HTML for Swagger UI.
   *
   * @private
   */
  #renderSwaggerUI(
    specUrl: string,
    title: string,
    head: string,
    scriptUrl: string,
    config: Record<string, unknown> | undefined,
    cssUrl: string | undefined,
  ): string {
    const configSpread = config ? `...${stringifyJSON(config)},` : ''

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${this.#esc(title)}</title>
  ${cssUrl ? `<link rel="stylesheet" href="${this.#esc(cssUrl)}">` : ''}
  ${head}
</head>
<body>
  <div id="swagger-ui"></div>
  <script src="${this.#esc(scriptUrl)}"></script>
  <script>
    window.onload = () => {
      SwaggerUIBundle({
        url: "${this.#esc(specUrl)}",
        dom_id: '#swagger-ui',
        ${configSpread}
      })
    }
  </script>
</body>
</html>`
  }

  /**
   * Renders HTML for Scalar UI.
   *
   * @private
   */
  #renderScalarUI(
    specUrl: string,
    title: string,
    head: string,
    scriptUrl: string,
    config: Record<string, unknown> | undefined,
  ): string {
    const configAttr = config ? `data-configuration="${this.#esc(stringifyJSON(config))}"` : ''

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${this.#esc(title)}</title>
  ${head}
</head>
<body>
  <script id="api-reference" data-url="${this.#esc(specUrl)}" ${configAttr}></script>
  <script src="${this.#esc(scriptUrl)}"></script>
</body>
</html>`
  }
}
